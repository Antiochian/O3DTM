function data_filename = generate_map(variable, fixed_data_paths, use_seasons, use_slope, t_wait, T_accuracy, iteration_limit, live_plot_interval)
% GENERATE_MAP generates parameter map using fitting routine and 1D model.
% variable = variable name to generate map of (needs relevant values
% defined below in 'Set up variable cases' section)
% fixed_data_paths = other variables to fix, use 'LOLA A0' to use LOLA
% albedo data and use the file path of a map data file (generated by this
% function) to use results from a previous run.
%
% data_filename = GENERATE_MAP(...) generates parameter map, saves data
% file and returns location of data file
%
% GENERATE_MAP(variable) generates map for given variable
%
% GENERATE_MAP(variable, fixed_data_paths) defines paths of data files
% containing parameter values to fix
%
% GENERATE_MAP(variable, fixed_data_paths, use_seasons) defines is seasons
% should be used for simulation
%
% GENERATE_MAP(variable, fixed_data_paths, use_seasons, use_slope) defines
% if map should use LOLA slope data
%
% GENERATE_MAP(variable, fixed_data_paths, use_seasons, use_slope, t_wait)
% defines how long to allow temperatures to stabilise
%
% GENERATE_MAP(variable, fixed_data_paths, use_seasons, use_slope, t_wait,
% T_accuracy) defines how accurate temperature fitting must be
%
% GENERATE_MAP(variable, fixed_data_paths, use_seasons, use_slope, t_wait,
% T_accuracy, iteration_limit) defines limit for number of iterations used
% in fitting
%
% GENERATE_MAP(variable, fixed_data_paths, use_seasons, use_slope, t_wait,
% T_accuracy, iteration_limit, live_plot_interval) defines how often data
% should be plotted while calculating

debug = false;

%% Deal with arguments
narginchk(1,7)
if nargin < 2
    fixed_data_paths = {};
end
if nargin < 3
    use_seasons = true;
end
if nargin < 4
    use_slope = true;
end
if nargin < 5
    t_wait = 60;
end
if nargin < 6
    T_accuracy = 0.005;
end
if nargin < 7
    iteration_limit = 100;
end
if nargin < 8
    live_plot_interval = 20;
end

%% Load data
fprintf('Loading data\n')
[height_matrix, lat_arr, long_arr] = read_lola_height_data();
if use_seasons
    seasons_str = 'Seasons';
    seasons_file_str = 'seasons';
    t_wait = 'seasons';
    [dtm_arr, sub_sun_long_arr, decl_arr] = read_horizons_data();
else
    seasons_str = sprintf('No seasons (%g P stabilisation time)', t_wait);
    seasons_file_str = sprintf('noSeasons%iPwait', t_wait);
    dtm_arr = [];
    sub_sun_long_arr = [];
    decl_arr = [];
end

if use_slope
    [aspect_matrix, slope_matrix] = convert_height_to_slope(height_matrix, lat_arr, long_arr);
    slope_str = 'LOLA slope data';
    slope_file_str = 'sloped';
else
    aspect_matrix = zeros(length(lat_arr), length(long_arr));
    slope_matrix = zeros(length(lat_arr), length(long_arr));
    slope_str = 'No slopes';
    slope_file_str = 'smooth';
end

parameters = define_parameters();
value_matrix = NaN(length(lat_arr), length(long_arr));

%% Set up variable cases
switch variable
    case 'A0'
        T_mode = 'max';
        value_min = 0;
        value_max = 1 - parameters.a*2^3 - parameters.b;
        value_calibration_arr = [parameters.A0];
        plot_label = 'Bond Albedo, A_0';
        plot_title = 'Bond Albedo';
    case 'H'
        T_mode = 'min';
        value_min = 0;
        value_max = 1;
        value_calibration_arr = [parameters.H];
        plot_label = 'H parameter (m)';
        plot_title = 'H parameter';
    case 'emissivity'
        T_mode = 'max';
        value_min = 0.5;
        value_max = 1;
        value_calibration_arr = [parameters.emissivity];
        plot_label = 'Emissivity';
        plot_title = 'Emissivity';
    otherwise
        error('Unknown variable chosen')
end

[T_diviner_matrix, ~, ~, ltim_matrix, dtm_matrix] = read_diviner_temperatures(T_mode);

%% Deal with fixed data
custom_parameters_raw = struct;
fixed_variables = {};
fixed_data_struct = struct;
if isempty(fixed_data_paths)
    use_fixed_data = false;
    fixed_variable_str = '';
else
    if ischar(fixed_data_paths)
        fixed_data_paths = {fixed_data_paths};
    end
    use_fixed_data = true;
    fixed_variable_str = '_';
    plot_title = sprintf('%s (using ', plot_title);
    for i = 1:length(fixed_data_paths)
        switch fixed_data_paths{i}
            case 'LOLA A0'
                fixed_variables{i} = 'A0';
                albedo_matrix = read_lola_A0_data();
                scaled_albedo_matrix = scale_data(albedo_matrix, parameters.A0);
                fixed_data_struct.A0 = scaled_albedo_matrix;
                plot_title = sprintf('%s%s, ', plot_title, 'LOLA scaled A0');
                fixed_variable_str = sprintf('%s%s', fixed_variable_str, 'LOLA-scaled-A0');
            case 'LOLA A0 unscaled'
                fixed_variables{i} = 'A0';
                albedo_matrix = read_lola_A0_data();
                fixed_data_struct.A0 = albedo_matrix;
                plot_title = sprintf('%s%s, ', plot_title, 'LOLA unscaled A0');
                fixed_variable_str = sprintf('%s%s', fixed_variable_str, 'LOLA-unscaled-A0');       
            otherwise
                data_from_file = load(fixed_data_paths{i});
                data_from_file = data_from_file.data;
                fixed_data_struct.(data_from_file.variable) = data_from_file.value_matrix;
                fixed_variables{i} = data_from_file.variable;
                plot_title = sprintf('%s%s, ', plot_title, data_from_file.variable);
                fixed_variable_str = sprintf('%s%s', fixed_variable_str, fixed_variables{i});
        end
    end
    plot_title = sprintf('%s data)', plot_title(1:end-2));
    fixed_variable_str = sprintf('%sfixed', fixed_variable_str);
end
plot_title = {plot_title, sprintf('1D Hayne thermal model | %s | %s | Accuracy: %g K | Value range: %g to %g', slope_str, seasons_str, T_accuracy, value_min, value_max)};
%% Prepare for loop
fprintf('\nRunning simulation for:\n%s\n%s\n\n', plot_title{1}, plot_title{2})
% fprintf(' LAT. = Latitude simulation is currently running for\n')
% fprintf(' PROGR. = Progress of current simulation\n')
% fprintf(' LAT. T. = Time for simulation to calculate values for entire latitude\n')
% fprintf(' PREDICTED FINISH = Predicted finish time of simulation\n')
start_dt = datetime;
for i = 1:length(variable)+1
    fprintf(' ')
end
fprintf('|LATITUDE | PROGR.|LAT. T.|PREDICTED FINISH\n');
for lat_idx = 1:length(lat_arr)
    iter_dt = datetime;
    lat = lat_arr(lat_idx);
    fprintf('%s | %+07.3f |', variable, lat);
    parfor long_idx = 1:length(long_arr)
        long = long_arr(long_idx);
        %% Find value
        T_diviner = T_diviner_matrix(lat_idx, long_idx);
        aspect = aspect_matrix(lat_idx, long_idx);
        slope = slope_matrix(lat_idx, long_idx);
        if use_seasons
            wait_time = dtm_matrix(lat_idx, long_idx);
        else
            wait_time = t_wait;
        end
        measurement_time = mod(0.5 + ltim_matrix(lat_idx, long_idx)/24,1);
        custom_parameters = custom_parameters_raw;
        if use_fixed_data
            for i = 1:length(fixed_variables)
                custom_parameters.(fixed_variables{i}) = fixed_data_struct.(fixed_variables{i})(lat_idx, long_idx);
            end
        end
        T_model_arr = [];
        value_model_arr = [];
        theta_arr = [];
        value = value_min;
        if debug
            fprintf('\nT_diviner = %07.3f',T_diviner)
        end
        for convergence_iter = 1:iteration_limit
            % Start by getting extreme values
            if convergence_iter == 2
                value = value_max;
            end
            custom_parameters.(variable) = value;
            [T_model, theta_arr] = hayne_1d_model(lat, wait_time, measurement_time, aspect, slope, custom_parameters, theta_arr, long, dtm_arr, sub_sun_long_arr, decl_arr);
            T_model_arr(end+1) = T_model;
            value_model_arr(end+1) = value;
            if debug
                fprintf('\n%06f => ', value)
                fprintf('%07.3f ', T_model)
            end
            if isnan(T_model)
                % Deal with errors
                if debug
                    fprintf('NaN\n')
                    cla
                    plot(value_model_arr, T_model_arr,'-*', value, T_diviner, 'x')
                    drawnow
                end
                value = NaN;
                break
            elseif convergence_iter > 2 + length(value_calibration_arr) && abs(T_model - T_diviner) < T_accuracy
                % Check for solution after doing at least 1 interpolation
                if debug
                    fprintf('DONE in %i\n',convergence_iter)
                    clf
                    plot(value_model_arr, T_model_arr,'-*', value, T_diviner, 'o')
                    drawnow
                end
                break
            elseif convergence_iter > 1 && (T_diviner > max(T_model_arr) || T_diviner < min(T_model_arr))
                % Deal with unphysical values (T_diviner outside range of
                % temperatures predicted by model)
                if debug
                    fprintf('x\n')
                    cla
                    plot(value_model_arr, T_model_arr,'-*', value, T_diviner, 'x')
                    drawnow
                end
                value = NaN;
                break
            elseif convergence_iter > 1 && convergence_iter <= 1 + length(value_calibration_arr)
                % Set value near where it is expected to speed up finding
                % the correct value
                value = value_calibration_arr(convergence_iter - 1);
            elseif convergence_iter > 1 + length(value_calibration_arr)
                % Perform interpolation to find better approximation to
                % value
                [T_model_arr_unique, unique_idxs] = unique(T_model_arr);
                value_model_arr_unique = value_model_arr(unique_idxs);
                value = interp1(T_model_arr_unique, value_model_arr_unique, T_diviner, 'pchip');
                if debug
                    fprintf('-->')
                end
            end
            
            if convergence_iter == iteration_limit
                % Deal with loops that do not converge
                if debug
                    fprintf('LIMIT')
                    cla
                    plot(value_model_arr, T_model_arr,'-*', value, T_diviner, 'x')
                    drawnow
                end
                value = NaN;
                % fprintf('\nIteration limit reached for lat=%f long=%f\n', lat, long_arr(long_idx))
            end
        end
        if value < value_min || value > value_max
            % Ensure value is within expected range
            if debug
                fprintf('xxx\n')
                cla
                plot(value_model_arr, T_model_arr,'-*', value, T_diviner, 'x')
                drawnow
            end
            value = NaN;
        end
        value_matrix(lat_idx, long_idx) = value;
    end
    iteration_time = duration(datetime - iter_dt,'Format','mm:ss');
    fraction_complete = lat_idx/length(lat_arr);
    finish_time = datestr(datetime + (datetime - start_dt)*(1-fraction_complete)/fraction_complete, 'HH:MM:SS dd/mm');
    fprintf(' %04.1f%% | %s | %s\n', 100*lat_idx/length(lat_arr), iteration_time, finish_time)
    if live_plot_interval && mod(lat_idx-1, live_plot_interval)==0
        temp_plot_title = sprintf('Generating map (%.0f%% complete)', 100*lat_idx/length(lat_arr));
        plot_map(lat_arr, long_arr, value_matrix, temp_plot_title, plot_label);
    end
end

%% Save data
creation_dt = datetime;
plot_title{2} = sprintf('%s | Simulated on: %s', plot_title{2}, datestr(creation_dt, 'YYYY-mm-dd HH:MM:SS'));
fprintf('Saving data\n')
root_filename = sprintf('outputs/1d_model_maps/%s%s_%s_%s_%sTaccuracy', variable, fixed_variable_str, slope_file_str, seasons_file_str, string(T_accuracy));
data = struct;
data.variable = variable;
data.value_matrix = value_matrix;
data.lat_arr = lat_arr;
data.long_arr = long_arr;
data.t_wait = t_wait;
data.T_accuracy = T_accuracy;
data.iteration_limit = iteration_limit;
data.value_max = value_max;
data.value_min = value_min;
data.value_calibration_arr = value_calibration_arr;
data.use_slope = use_slope;
data.use_seasons = use_seasons;
data.fixed_data = fixed_data_paths;
data.T_mode = T_mode;
data.plot_title = plot_title;
data.plot_label = plot_label;
data.root_filename = root_filename;
data.temperature_model = '1D';
data.interpolation_method = 'Interpolate (starting with values at extremes) to find value where abs(T_model-T_diviner) < T_accuracy';
data.description = 'Data for variable created by generate_maps.m using 1D Hayne model and matching times to Diviner measurement times';
data.created = creation_dt;
data_filename = sprintf('%s_data.mat', root_filename);
save(data_filename, 'data')

%% Save plots
fprintf('Saving plots\n')
prctile_min = prctile(reshape(value_matrix,numel(value_matrix),1),10);
prctile_max = prctile(reshape(value_matrix,numel(value_matrix),1),90);
% Histogram
plot_histogram(value_matrix, plot_title, plot_label)
target_filename = sprintf('%s_histogram_full.png', root_filename);
print(target_filename, '-dpng', '-r160')
plot_histogram(value_matrix, plot_title, plot_label, [prctile_min, prctile_max])
target_filename = sprintf('%s_histogram_focus.png', root_filename);
print(target_filename, '-dpng', '-r160')
% Map
plot_map(lat_arr, long_arr, value_matrix, plot_title, plot_label);
target_filename = sprintf('%s_map_full.png', root_filename);
print(target_filename, '-dpng', '-r160')
if strcmp(variable, 'A0')
    set(gca, 'color', [1 1 0.5]);
    fig = gcf;
    fig.InvertHardcopy = 'off';
    colormap('gray')
    target_filename = sprintf('%s_map_gray.png', root_filename);
    print(target_filename, '-dpng', '-r160')
    fig.InvertHardcopy = 'on';
    plot_map(lat_arr, long_arr, value_matrix, plot_title, plot_label);
end
caxis([prctile_min, prctile_max])
target_filename = sprintf('%s_map_focus.png', root_filename);
print(target_filename, '-dpng', '-r160')

fprintf('\nDONE in %s\n\n', datetime-start_dt)
end